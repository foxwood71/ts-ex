[ 주요 내장 타입 ]
  - 원시 타입
    number, string, boolean, symbol, null, undefined, bigint
    → 자바스크립트와 1:1 매칭되는 값의 형태

  - 배열 및 튜플
    T[] 또는 Array<T>
    [T, U](튜플)

  - 객체 타입
    object, { [key: string]: any }, Record, Partial, Required 등

  - 함수 타입
    (args: Args) => ReturnType

  - 특수 타입
    void (함수 반환 무의미), any, unknown, never

  - 표준 유틸리티 타입
    Readonly<T>
    Partial<T>
    Required<T>
    Record<K, T>
    Pick<T, K>
    Omit<T, K>
    Exclude<T, U>
    Extract<T, U>
    NonNullable<T>
    Parameters<T>
    ReturnType<T>

  - ES6+ 내장 타입 (인터페이스/제네릭)
    Promise<T>
    Iterable<T>
    Iterator<T, TReturn = any, TNext = undefined>
    IteratorResult<T, TReturn = any>
    AsyncIterable<T>
    Map<K, V>, Set<T>, WeakMap<K, V>, WeakSet<T>
    Symbol, Date, RegExp

[ 대표적인 표준 심볼 프로퍼티 목록 ]
 - Symbol.iterator : 객체를 반복 가능한(iterable) 객체로 만듭니다. for...of와 스프레드 구문 등에서 사용.
 - Symbol.asyncIterator : 비동기 반복(iteration) 동작을 정의할 때 사용.
 - Symbol.toStringTag : Object.prototype.toString.call(obj)의 결과 문자열을 커스터마이징.
 - Symbol.toPrimitive : 객체를 원시 타입으로 변환할 때의 동작을 정의.
 - Symbol.hasInstance : instanceof 연산자의 동작 방식을 변경.
 - Symbol.isConcatSpreadable : 배열 병합 시 객체가 배열처럼 펼쳐질지 결정.
 - Symbol.match : 정규식 매칭과 관련된 메서드 사용 시 호출.
 - Symbol.replace : 정규식 치환과 관련된 메서드 사용 시 호출.
 - Symbol.search : 정규식 검색과 관련된 메서드 사용 시 호출.
 - Symbol.split : 문자열 분리(split) 동작을 정의.
 - Symbol.species : 파생 객체 생성 시 사용할 생성자 지정.
 - Symbol.unscopables : with문에서 특정 속성을 숨기는 데 사용.

[ 참고 ]
  이 심볼들은 내장 객체나 커스텀 클래스에서 메서드 이름 대신 사용해 해당 동작을 재정의할 수 있습니다.
  예를 들어, 클래스에 [Symbol.iterator]() 메서드를 구현하면 그 객체는 이터러블 객체로 동작합니다.

[ 1. Symbol.iterator ] 
  - 설명
    객체를 반복 가능한 이터러블로 만들어 줍니다.
    for...of 문, 스프레드 연산자 등에서 호출됩니다.

  - 예제
    class MyCollection {
      private items = [1, 2, 3];
      
      [Symbol.iterator]() {
        let index = 0;
        const items = this.items;
        return {
          next() {
            if (index < items.length) {
              return { value: items[index++], done: false };
            } else {
              return { value: undefined, done: true };
            }
          }
        };
      }
    }

    const collection = new MyCollection();
    for (const item of collection) {
      console.log(item); // 1, 2, 3 출력
    }

[ 2. Symbol.toPrimitive ]
  - 설명
    객체가 원시 타입(문자열, 숫자 등)으로 변환될 때 호출됩니다.
    +obj, String(obj), alert(obj) 같은 동작에 영향을 줍니다.

  - 예제
    const obj = {
      [Symbol.toPrimitive](hint: string) {
        if (hint === 'number') {
          return 42;
        }
        if (hint === 'string') {
          return 'hello';
        }
        return true;
      }
    };

    console.log(+obj); // 42
    console.log(`${obj}`); // "hello"
    console.log(obj + ''); // "true"

[ 3. Symbol.hasInstance ]
  - 설명
    instanceof 연산자 동작을 커스터마이징합니다.

  - 예제
    class MyClass {
      static [Symbol.hasInstance](obj: any) {
        return obj.custom instanceof Date;
      }
    }

    const obj = { custom: new Date() };
    console.log(obj instanceof MyClass); // true

[ 4. Symbol.toStringTag ]
  - 설명
    Object.prototype.toString.call(obj)의 결과를 커스터마이징합니다.

  - 예제
    const obj = {
      [Symbol.toStringTag]: 'MyCustomObject'
    };

    console.log(Object.prototype.toString.call(obj)); // "[object MyCustomObject]"

[ 5. Symbol.unscopables ]
  - 설명
    with 문 내에서 특정 프로퍼티가 스코프에서 숨겨지도록 설정합니다.

  - 예제
    const obj = {
      foo: 1,
      bar: 2,
      baz: 3,
      [Symbol.unscopables]: {
        __proto__: null,
        foo: false,  // `foo`는 with문 내에서 사용 가능
        bar: true,   // `bar`는 with문 내에서 숨김(불가능)
        // baz는 생략되어 기본적으로 사용 가능
      }
    };

    with (obj) {
      console.log(foo); // 1
      console.log(bar); // ReferenceError: bar is not defined
      console.log(baz); // 3
    }


[ 제너레이터 기본 특징 ]
  - function* 형태로 정의하며 호출 시 실행되지 않고 제너레이터 객체를 반환합니다.
  - 반환된 제너레이터 객체는 next() 메서드를 가지며, 호출할 때마다 value와 done 정보를 가진 객체를 반환합니다.
  - yield 에서 실행이 중단되고, next() 호출 시 다시 실행재개됩니다.
  - 이터러블과 이터레이터 프로토콜을 자동으로 충족합니다.

[ Symbol.iterator와 제너레이터의 관계 ]
  - Symbol.iterator 메서드는 반복 가능한 객체를 정의할 때 사용하는 표준 심볼입니다.
  - 일반적으로 Symbol.iterator는 직접 next()를 구현한 객체를 반환해야 하지만,
  - 제너레이터 함수를 Symbol.iterator 메서드로 정의하면, 제너레이터가 자동으로 이터레이터를 반환해 간결합니다.

  - 예제 (간단)
    // 제너레이터 함수 정의
    function* generatorFunc() {
      yield 1;  // 첫번째 next 호출 시 여기서 멈춤, 1 반환
      yield 2;  // 두번째 next 호출 시 여기서 멈춤, 2 반환
      yield 3;  // 세번째 next 호출 시 여기서 멈춤, 3 반환
    }

    // 제너레이터 객체 생성
    const gen = generatorFunc();

    // next 호출
    console.log(gen.next()); // { value: 1, done: false }
    console.log(gen.next()); // { value: 2, done: false }
    console.log(gen.next()); // { value: 3, done: false }
    console.log(gen.next()); // { value: undefined, done: true }

  - 예제 (제너레이터를 이용한 Symbol.iterator 구현)
    const iterable = {
      *[Symbol.iterator]() {
        yield 1;
        yield 2;
        yield 3;
      }
    };

    for (const value of iterable) {
      console.log(value); // 1, 2, 3
    }

[yield]
  - yield의 주요 특징
    실행 일시 중지: 제너레이터 함수 실행 중 yield를 만나면 함수가 일시 중지되고, 해당 값이 호출자에게 반환됩니다(yield 오른쪽의 값을 호출자에게 반환).
    값 반환과 재개: 외부에서 .next()를 호출하면 함수가 yield에서 중지된 지점부터 다시 실행됩니다.
    다중 값 반환 가능: return과 달리 여러 번 yield를 사용해 여러 값을 순차적으로 반환할 수 있습니다.
    내부 상태 유지: 함수 내부 상태, 변수 등이 yield 사이에 그대로 유지됩니다.

  - 기본문법
    function* generator() {
    yield expression;     // expression 값을 반환하며 실행 중지
    yield;               // undefined 반환하며 실행 중지
  }

  - yield는 양방향 통신도 가능: generator.next(value)로 값을 전달하면, 이 값이 yield 표현식의 결과로 반환됩니다.
    function* generator() {
      const msg = yield 'hello';
      console.log(msg);
    }

    const gen = generator();
    console.log(gen.next());        // { value: 'hello', done: false }
    console.log(gen.next('world')); // 'world'가 console.log에 출력됨

  - yield와 yield*의 차이점

    yield 사용 (직접 반복문 필요)

      function* gen() {
        const iterable = [1, 2, 3];
        for (const val of iterable) {
          yield val;
        }
      }

    yield* 사용 (간단하게 표현)
    function* gen() {
      yield* [1, 2, 3];
    }